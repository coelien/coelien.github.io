---
title: MIT6.S081笔记：lecture 5
tags: 
- MIT6.S081
- OS
categories:
- courses
- Operating System
---

# MIT6.S081笔记：lecture 5 calling conventions and stack

## Calling convenstions

### RISC-V Register File

<img src="https://raw.githubusercontent.com/coelien/image-hosting/master/img/regfile.png" alt="regfile" style="zoom:50%;" />

### Integer Instructions

- lb t0, 8(sp)

  loads from memory address (sp+8) into register t0

  lb = load byte, lh = load halfword, lw = load word, ld = load doubleword

- add a0, t0, t1

  adds value of t0 to the value of t1 and stores the sum into a0

- addi a0, t0, -10

  adds value of t0 to the value -10 and stores the sum into a0

- mul a0, t0, t1

  multiplies the value of t0 to the value of t1 and stores the product int a0

### Pseudo Instructions

- translate to real instructions by assembler

<img src="https://raw.githubusercontent.com/coelien/image-hosting/master/img/pseudo.png" alt="pseudo" style="zoom:50%;" />

### Branching Instructions

-  a way to jump to different parts of your code
- Branching refers to the "conditional jump" instructions, such as `beq, bne, bgt, bge, blt, ble` for branch-if equals, not equals, greater than, greater than or equals, less than, and less than or equals, respectively.

```assembly
# t0 = 0
li      t0, 0
li      t2, 10
loop_head:
bge     t0, t2, loop_end
# Repeated code goes here
addi    t0, t0, 1
j		loop_head
loop_end:
```



## Stack

### Stack frame

<img src="https://raw.githubusercontent.com/coelien/image-hosting/master/img/image-20230614143513990.png" alt="image-20230614143513990" style="zoom:50%;" />

- stack frame is generated by function calls
- start from high addresses and grow downwards to low addresses
- the return address and to prev frame pointer are at a predictable position

- sp - bottom of the stack
- fp - top of the current frame

### Use backtrace to debug

